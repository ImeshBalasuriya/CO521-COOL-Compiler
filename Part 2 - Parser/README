README file for Programming Assignment 3 (C++ edition)
======================================================

Your directory should now contain the following files:

 Makefile
 README
 cool.y
 bad.cl
 good.cl
 cool-tree.handcode.h
 cool-tree.cc		  -> [cool root]/src/PA3/cool-tree.cc
 cool-tree.aps		  -> [cool root]/src/PA3/cool-tree.aps
 dumptype.cc		  -> [cool root]/src/PA3/dumptype.cc
 handle_flags.c           -> [cool root]/src/PA3/handle_flags.cc
 parser-phase.cc	  -> [cool root]/src/PA3/parser-phase.cc
 stringtab.cc		  -> [cool root]/src/PA3/stringtab.cc
 tokens-lex.cc		  -> [cool root]/src/PA3/tokens-lex.cc
 tree.cc		  -> [cool root]/src/PA3/tree.cc
 utilities.cc		  -> [cool root]/src/PA3/utilities.cc
 *.d			  dependency files
 *.*			  other generated files

The include (.h) files for this assignment can be found in 
[cool root]/include/PA3

	The Makefile contains targets for compiling and running your
	program. DO NOT MODIFY.
    
	The README contains this info. Part of the assignment is to
	fill in the README with the write-up for your project. You should
	explain design decisions, explain why your code is correct, and why
	your test cases are adequate. It is part of the assignment to
	clearly and concisely explain things in text as well as to comment
	your code. Just edit this file.

	cool.y is the skeleton for the parser specification that you
	are to write. It already contains productions for the program
	and the classes. Use them as an example to write the remaining
	productions.  You should also read the bison documentation.
	This skeleton will compile and run as is, but it doesn't
	do much.

	good.cl, bad.cl test a few features of the grammar. You should
	add tests to ensure that good.cl exercises every legal
	construction of the grammar and that bad.cl exercises as many
	different parsing errors as you can squeeze into one file.

	cool-tree.aps contains the definitions for the tree language
	which you use to construct the abstract syntax tree (AST).
	From this file, cool-tree.h and cool-tree.cc are automatically 
        generated by a utility that compiles the specification into
        C++ functions for producing and consuming the tree nodes.
        This file is provided for your reference.  DO NOT MODIFY.

        tree.{cc|h} contain definitions used by the tree package.
        cool-tree.handcode.h is the handwritten extension to
        cool-tree.h.  If you read cool-tree.h and cool-tree.cc, you will
        note that there are "hooks" for extending the classes
        declarations.  Extending and modifying the tree package is
        discussed in the "Cool Tour", but you do not need to (and should
        not) modify the tree package for this assignment.

	tokens-lex.cc is a lexer capable of reading a token stream from
	console in the format produced by the lexer phase. DO NOT
	MODIFY.

        parser-phase.cc contains a driver to test the parser. DO NOT
        MODIFY.

	dumptype.cc prints the AST out in a form readable by the
	semant phase of the compiler. DO NOT MODIFY.

	handle_flags.cc implements routines for parsing command line
        flags. DO NOT MODIFY.

        The rest of the files are created as byproducts of `bison'.
        `cool-parse.cc' is the generated C++ file containing the
        parser.

	Files not discussed are covered in the README for PA2.

Instructions
------------

	To compile your parser program type:

	% make parser

	This produces an executable named "parser" which is standalone
	phase of the Cool compiler.  It requires lexer, semant, and cgen
	to do anything useful.

	To test your parser on a file 'foo.cl' type

	% myparser foo.cl

	myparser is a shell script that "glues" together lexer and
	parser using pipes.

	To run your parser on the files good.cl and bad.cl type:

	% make dotest

	To run the (provided) lexer and your parser on a file called test.cl type:

	% ./lexer test.cl | ./parser

	If you think your parser is correct and behaves like
	the one we wrote, you may want to run a COOL compiler using
	your parser:

	% mycoolc foo.cl

	To overwrite the default lexical analyzer with yours, replace 
	lexer (which is a symbolic link to the "official" lexer) with
        your lexer from PA2.

	If you change architectures you must issue

	% make clean

	when you switch from one type of machine to the other.
	If at some point you get weird errors from the linker,	
	you probably forgot this step.

	GOOD LUCK!

---8<------8<------8<------8<---cut here---8<------8<------8<------8<---

Write-up for PA3
----------------

Group: 06
Members: Balasuriya I.S. (E/17/018), Rupasinghe R.H. (E/17/296)

Rules for the non-terminals: The definition of the AST nodes are given in cool-tree.aps and these methods were used to define the rules for the non-terminals. Given below are the non-terminals.
	1) program (Type - program):
		- A program consists of one or more class non-terminals.The program constructer is defined as { constructor program(classes : Classes) : Program; }. This constructor takes a class_list(defined below)
	non-terminal as input.The root of the abstract syntax tree was saved in a global variable. 
	
    2) class_list (Type - classes):
    	A class list can contain either one or more classes.
    	- If it is a single class we use { Classes single_Classes(Class_); } to create a Classes phylum with a single class. Parse results??
    	- If it is several classes, we use { Classes append_Classes(Classes, Classes); } and parse results.
    
    3) class (Type - class_):
    	A class is defined as ' class TYPE [inherits TYPE] { [[feature;]]∗} ', where mentioning the inherited class is optional for certain instances and the list of features could be either zero or more.
    	- In cases where inheritance does not take place, the constructor { constructor class_(name : Symbol; parent: Symbol; features : Features; filename : Symbol): Class_; } was used. The required features were
    defined as a feature_list(defined below) and the add_string methods were used in both the idtable(to add "Object") and stringtable(to add the filename).
    	- In cases where inheritance takes place, the same constructor was used and the add_string method of the strigtable was used once again.
    
    4) feature_list (Type - features):
    	A feature list can be either empty or not. A feature ends with a ';'.
    	- When the list is empty, we use { Features nil_Features(); } which creates a nil Features phylum.
    	- When the list contains only one feature, it uses { Features single_Features(Feature); } to create a Features phylum with a single feature.
    	- When the list has more than one feature, it uses the prototype { Features append_Features(Features, Features); } and makes recursive calls to the same rule.
    
    5) feature (Type - feature):
    	A feature is defined as ' ID( [ formal [[, formal]]∗ ] ) : TYPE { expr } ' or ' ID : TYPE [ <- expr ] ', where the list of formals are optional and the assignment at the end is optional as well.
    	- For the first case where the formal list is provided, the constructor { constructor method(name : Symbol; formals : Formals; return_type : Symbol; expr: Expression) : Feature; } was used. The formals needed for
    this constructor is handled by the rule formal_list and the relevant expression is handled by the rule expression.
    	- For the second case where the formal list is not provided and the assignment is optional, the constructor { constructor attr(name, type_decl : Symbol; init : Expression) : Feature; } was used. The status of
    the assignement is handled by opt_init which is defined as another rule.
    	 
    	
    6) formal_list (Type - formals):
    	A formal list can be either empty or non-empty. 
    	- When the list is empty, we use { Formals nil_Formals(); } which creates a nil Formals phylum.
    	- When the list contains only one formal, it uses { Formals single_Formals(Formal); } to create a Formals phylum with a single formal.
    	- When the list has more than one formal, it uses the prototype { Formals append_Formals(Formals, Formals); } and makes recursive calls to the same rule.
    	
    7) formal (Type - formal):
    	A formal is defined as ' ID : TYPE '.
    	- The constructor { constructor formal(name, type_decl: Symbol) : Formal; } can be used to create a Formal.
    
    8) case_list (Type - cases):
    	This is the rule for handling multiple ' ID : TYPE => expr; ' statements.
    	- When there is only one instance of this, we call { Cases single_Cases(Case); } which creates a Cases phylum with one case. It should be noticed that a single case ends with a ';'.
    	- When there are multiple instances of this, we call { Cases append_Cases(Cases, Cases); } and makes recursive calls to the same rule.
    
    9) case_ (Type - case):
    	This handles the statement ' ID : TYPE => expr; '. 
    	- The rule uses the constructor { constructor branch(name, type_decl: Symbol; expr: Expression): Case; }.
    
   10) expr_list (Type - expressions):
   		Expressions in Cool can be either nil, single or multiple. Ex: When specifying the defined parameters for a method, there can zero or mutiple values passed for the paramaeters. This rule is 
   	used to convert these types of expressions to Expressions.
   		- When the required expression is nil, we use { Expressions nil_Expressions(); } which creates a nil Expressions phylum.
   		- When we need a single expression, we use { Expressions single_Expressions(Expression); } which creates a Expressions phylum with one expression.
   		- When the required statement includes multiple expressions (comma seperated), we use { Expressions append_Expressions(Expressions, Expressions); } and make recursive calls to the same rule.
   	
   11) expression (Type - expression):
   		There are sevaral ways of defining an expression in Cool. 
   		- The assign statement is defined as ' ID <- expr '. For assign statement expressions, we use the constructor { constructor assign(name : Symbol; expr : Expression) : Expression; } and we make 
   	recursive calls to the same rule for the expression at the end.
   		- The static dispatch operation is defined as ' expr[@TYPE].ID( [ expr [[, expr]]∗ ] ) ', where defining the class name is required (It is orginally defined as optional as given in the statement).
   	We use the constructor { constructor static_dispatch(expr: Expression; type_name : Symbol; name : Symbol; actual : Expressions) : Expression; }. This definition of the rule makes recursive calls to 
   	the same rule and calls the rule expr_list which was defined earlier.
   		- The non-static dispatch operation which does not specify a class name uses the constructor { constructor dispatch(expr : Expression; name : Symbol; actual : Expressions) : Expression; }. 
   	This definition of the rule makes recursive calls to the same rule and calls the rule expr_list which was defined earlier.
   		- For the self dispatch operation, defined by ' ID( [ expr [[, expr]]∗ ] ) ', we use the dispatch constructor as before, but by passing the "self" object as the first parameter(To convert "self" to an 
   	expression we use the constructor { constructor object(name: Symbol): Expression; } which converts a Symbol to an Expression). Since the expression list in the definition is optional, we call the rule 
   	expr_list such that it would return the necessary Expressions phylum.
   		- When handling conditionals defined by ' if expr then expr else expr fi ', we need to recursively call the rule expression. For this definition of the rule we use the constructor 
   	{ constructor cond(pred, then_exp, else_exp : Expression): Expression; }.
   		- When handling while loops defined by ' while expr loop expr pool ', we need to recursively call the rule expression. For this definition of the rule we use the constructor 
   	{ constructor loop(pred, body: Expression) : Expression; }.
   		- Block expressions defined by ' { [[expr; ]]+} ', are handled by calling the rule block_expr(defined below; this is defined seperately since block expressions do not have comma seperated expressions).
   	We use the constructor { constructor block(body: Expressions) : Expression; } for this definition of the rule.
   		- Let statements, defined by ' let ID : TYPE [ <- expr ] [[, ID : TYPE [ <- expr ]]]∗ in expr ' are handled by calling a seperate rule let_stmt(defined below) which calls the let constructor to return an Expression.
   		- Case statements, defined by ' case expr of [[ID : TYPE => expr; ]]+esac ', are handled by calling the same rule expression and the rule case_list. The constructor used for this is 
   	{ constructor typcase(expr: Expression; cases: Cases): Expression; }.
   		- New statements, defined by ' new TYPE ', are handled using the constructor { constructor new_(type_name: Symbol): Expression; }.
   		- Is void expressions, defined by ' isvoid expr ', are handled using the constructor { constructor isvoid(e1: Expression): Expression; }.
   		- Addition, defined by ' expr + expr ', is handled by the constructor { constructor plus(e1, e2: Expression) : Expression; }, while recursively calling the same rule.
   		- Subtraction, defined by ' expr - expr ', is handled by the constructor { constructor  sub(e1, e2: Expression) : Expression; }, while recursively calling the same rule.
   		- Multiplication, defined by ' expr * expr ', is handled by the constructor { constructor  mul(e1, e2: Expression) : Expression; }, while recursively calling the same rule.
   		- Division, defined by ' expr / expr ', is handled by the constructor { constructor divide(e1, e2: Expression) : Expression; }, while recursively calling the same rule.
   		- Negation, defined by ' ˜expr ', is handled by the constructor { constructor  neg(e1: Expression) : Expression; }, while recursively calling the same rule.
   		- The comparison operator less than, defined by ' expr < expr ', is handled by the constructor { constructor   lt(e1, e2: Expression) : Expression; }, while recursively calling the same rule.
   		- The comparison operator less than or equal, defined by ' expr <= expr ', is handled by the constructor { constructor  leq(e1, e2: Expression) : Expression; }, while recursively calling the same rule.
   		- The comparison operator equal, defined by ' expr = expr ', is handled by the constructor { constructor   eq(e1, e2: Expression) : Expression; }, while recursively calling the same rule.
   		- The complement operation, defined by ' not expr ', is handled by the constructor { constructor comp(e1: Expression) : Expression; }, while recursively calling the same rule.
   		- Bracketed expressions, defined by ' (expr) ', gets directly evaluated and the expression rule is called.
   		- The object id, defined by ' ID ', is handled by the constructor { constructor object(name: Symbol): Expression; }.
   		- Integers are handled by the constructor { constructor int_const(token: Symbol) : Expression; }.
   		- Strings are handled by the constructor { constructor string_const(token: Symbol) : Expression; }.
   		- Booleans are handled by the constructor { constructor bool_const(val: Boolean) : Expression; }.
   
    12) block_expr (Type - expressions):
    	This rule is used to evaluate the block expressions in the expression rule. They can be either one or more.
    	- When there is a single expression, we use { Expressions single_Expressions(Expression); } which creates a Expressions phylum with one expression.
    	- When there are multiple space-separated expressions, we use { Expressions append_Expressions(Expressions, Expressions); } and make recursive calls to the same rule.
    
    13) opt_init (Type - expression):
    	Used in the definition for the rules feature and let_stmt(defined below). This rule defines the optional assignment opration defined by ' [ <- expr ] '.
    	- When this expression is optional, we use the constructor { constructor no_expr(): Expression; }, which creates a nil Expression phylum.
    	- When this is not optional, we directly return the given expression of phylum Expression.
    
    14) let_stmt (Type - expression):
    	This rule defines the ' ID : TYPE [ <- expr ] [[, ID : TYPE [ <- expr ]]]∗ in expr ' portion of the let statement, where the assignment is optional and there can be nested statements.
    	- When we have reached the rightmost statement, we use the constructor { constructor let(identifier, type_decl: Symbol; init, body: Expression): Expression; }.
    	- When we have not yet reached the rightmost statement, we recursively call the same rule while using the same constructor.


Precedence: The precedence declarations in Bison are used to define the order of precedence in Cool. We have defined them in the order from the least precedence to the highest. All binary 
operations are left-associative (defined by '%left'), with the exception of assignment, which is right-associative (defined by '%right'), and the three comparison operations, which do not associate (defined by '%nonassoc').
The unary operators are defined using '%precedence'.

Error Handling:

Testing:

































